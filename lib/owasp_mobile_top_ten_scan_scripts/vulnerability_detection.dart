import 'dart:io';
import 'dart:convert';
import 'package:yaml/yaml.dart';
import 'package:http/http.dart' as http;

import 'package:dart_tabulate/dart_tabulate.dart';
import 'package:console_bars/console_bars.dart';

import '../project_path_script/project_path.dart' as pp;

final github_advisory_script_console_bar = FillingBar(desc: "Loading", total: 1000, time: true, percentage:true);
final nvd_vulnerability_script_console_bar = FillingBar(desc: "Loading", total: 1000, time: true, percentage:true);
final vulnerability_check_console_bar = FillingBar(desc: "Loading", total: 1000, time: true, percentage:true);

Table vulnerability_table = Table();

Future<void> main() async {
  // Step 1: Check whether the provided Flutter project path is a valid path
  String? projectPath = pp.projectPath;
  if (projectPath == null || projectPath.isEmpty) {
    print('Invalid path provided.');
    return;
  }

  // Step 2: Locate the pubspec.lock file
  File lockFile = File('$projectPath/pubspec.lock');
  if (!lockFile.existsSync()) {
    print('pubspec.lock not found in the provided directory: $projectPath');
    return;
  }

  String content = lockFile.readAsStringSync();

  // Step 3: Parse dependencies from the pubspec.lock file
  final yamlMap = loadYaml(content);
  final dependencies = yamlMap['packages'] as Map;

  // Step 4: Fetch all vulnerabilities related to Dart, Flutter and Pub from the GitHib Advisort and NVD databases
  print('\n');

  await runFetchScripts();

  vulnerability_check_console_bar.desc = "[+] Checking dependencies for vulnerabilities";
  for (var i = 0; i < 1000; i++) {
      vulnerability_check_console_bar.increment();
      await Future.delayed(Duration(milliseconds: 1));
  }
  print('\n');

  vulnerability_table.theme.setWidth(32);
  vulnerability_table.addRow(["Dependency", "GHSA / CVE Id", "Database", "Severity", "Affected Version Range", "URL", "Description"]);

  // Step 5: Checking dependencies for vulnerabilities
  for (var dependency in dependencies.entries) {
    String packageName = dependency.key;
    String packageVersion = dependency.value['version'];
    await checkForVulnerabilities(packageName, packageVersion);
  }

  print('[+][+][+] Vulnerability Scanning Completed !!! [+][+][+]');
}



// Step 4: Run the scripts to fetch all vulnerabilities related to Dart, Flutter and Pub from the GitHib Advisort and NVD databases
Future<void> runScript(String scriptPath) async {
  // print('Running script: $scriptPath');
  scriptPath.contains('github_advisories') ? 
  {
    // print('Running script for Github Advisories'),
    github_advisory_script_console_bar.desc = "[+] Running script for Github Advisories",
    for (var i = 0; i < 1000; i++) {
      github_advisory_script_console_bar.increment(), 
      await Future.delayed(Duration(milliseconds: 10))
    }
  } : 
  {
    // print('Running script for NVD Vulnerabilities'),
    nvd_vulnerability_script_console_bar.desc = "[+] Running script for NVD Vulnerabilities",
    for (var i = 0; i < 1000; i++) {
      nvd_vulnerability_script_console_bar.increment(), 
      await Future.delayed(Duration(milliseconds: 10))
    }
  };

  print('\n');

  try {
    final result = await Process.run('dart', [scriptPath]);

    if (result.exitCode == 0) {
      // print('[+][+][+] Script executed successfully: $scriptPath [+][+][+]');
      // print('\n[+][+][+] Script executed successfully [+][+][+]\n');
      // print('Output:\n${result.stdout}');
    } else {
      print('Script execution failed: $scriptPath');
      print('Error:\n${result.stderr}');
    }
  } catch (e) {
    print('Error running script $scriptPath: $e');
  }
}

Future<void> runFetchScripts() async {
  const githubAdvisoriesScript = 'lib/vulnerability_database_scripts/fetch_github_advisories.dart';
  const nvdVulnerabilitiesScript = 'lib/vulnerability_database_scripts/fetch_nvd_vulnerabilities.dart';

  await runScript(githubAdvisoriesScript);
  await runScript(nvdVulnerabilitiesScript);

  print('[+][+][+] API scripts executed successfully [+][+][+]\n');
} 

// Step 5: Check vulnerabilities using OSV, NVD and GitHub Advisory databases
Future<void> checkForVulnerabilities(
    String packageName, String packageVersion) async {
  await checkWithOSV(packageName, packageVersion);
  await checkWithNVD(packageName, packageVersion);
  await checkWithGitHub(packageName, packageVersion);
}

Future<void> checkWithOSV(String packageName, String packageVersion) async {
  final osvUrl = 'https://api.osv.dev/v1/query';

  // JSON payload
  Map<String, dynamic> payload = {
    "package": {"name": packageName, "ecosystem": "Pub"}
  };

  try {
    final response = await http.post(
      Uri.parse(osvUrl),
      headers: {"Content-Type": "application/json"},
      body: jsonEncode(payload),
    );

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      if (data['vulns'] != null && data['vulns'].isNotEmpty) {
        for (var vuln in data['vulns']) {
          vulnerability_table.addRow(["$packageName", "${vuln['id']}", "OSV", "${vuln['database_specific']['severity']}", "< ${vuln['affected'][0]['ranges'][0]['events'][0]['fixed']}", "${vuln['references'][0]['url']}", "${vuln['summary']}"]);
        }
      } else {
        // print('$packageName@$packageVersion has no known vulnerabilities in OSV.');
      }
    } else {
      // print('Failed to fetch OSV details for $packageName (HTTP ${response.statusCode}).');
    }
  } catch (e) {
    print('Error checking OSV vulnerabilities for $packageName: $e');
  }
}

Future<void> checkWithNVD(String packageName, String packageVersion) async {
  final filePath = 'nvd_vulnerabilities.json';

  try {
    final file = File(filePath);

    if (!file.existsSync()) {
      print(
          'NVD vulnerabilities data file not found. Please run the fetch script first.');
      return;
    }

    final content = await file.readAsString();
    final vulnerabilities = jsonDecode(content);
    final packageAdvisories = vulnerabilities.toList();

    for (var advisory in packageAdvisories) {
      if (advisory['cve']['descriptions'][0]['value']
              .contains(packageName + ' package') ||
          advisory['cve']['descriptions'][0]['value']
              .contains(packageName + ' component')) {
        vulnerability_table.addRow(["$packageName", "${advisory['cve']['id']}", "NVD", "Severity", "< ${advisory['cve']['configurations'][0]['nodes'][0]['cpeMatch'][0]['versionEndExcluding']}", "${advisory['cve']['references'][0]['url']}", "Summary"]);        
      } else {
        // print('$packageName@$packageVersion has no known vulnerabilities in NVD.');
      }
    }
  } catch (e) {
    print('Error checking NVD vulnerabilities for $packageName: $e');
  }
}

Future<void> checkWithGitHub(String packageName, String packageVersion) async {
  const advisoryFile = 'github_advisories.json';

  try {
    // Read advisories from the local file
    final file = File(advisoryFile);

    if (!file.existsSync()) {
      print(
          'GitHub advisories file not found. Run fetch_github_advisories.dart first.');
      return;
    }

    final content = await file.readAsString();
    final advisories = jsonDecode(content);
    final packageAdvisories = advisories.toList();

    for (var advisory in packageAdvisories) {
      if (advisory['vulnerabilities'][0]['package']['name'] == packageName) {
        vulnerability_table.addRow(["$packageName", "${advisory['cve_id']}", "GitHub Advisories", "${advisory['severity']}", "${advisory['vulnerabilities'][0]['vulnerable_version_range']}", "${advisory['url']}", "${advisory['summary']}"]);
      } else {
        // print('$packageName@$packageVersion has no known vulnerabilities in GitHub Advisories.');
      }
    }
  } catch (e) {
    print('Error checking GitHub advisories for $packageName: $e');
  }
}
